# 工厂方法

**工厂方法** 是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

## 适合应用场景

- 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。

  工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。

- 如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。

  继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨别出该子类？解决方案是将各框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写。

- 如果你希望复用现有的对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法

  在处理大型资源密集型对象（比如数据库连接、文件系统和网络资源）时，你会经常碰到这种资源需求。

## 实现方式

1. 让所有产品都遵循同一接口，该接口必须声明对所有产品都有意义的方法。
2. 在创建类中添加一个空的工厂方法，该方法的返回类型必须遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们 依次替换为对于工厂方法的调用， 同时将创建产品的代码移 入工厂方法。 你可能需要在工厂方法中添加临时参数来控制 返回的产品类型。工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 `switch` 分支 运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。
4. 现在， 为工厂方法中的每种产品编写一个创建者子类， 然后 在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。
5. 如果应用中的产品类型太多， 那么为每个产品创建子类并无 太大必要， 这时你也可以在子类中复用基类中的控制参数。
6. 如果代码经过上述移动后， 基础工厂方法中已经没有任何代 码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其 他语句， 你可以将其设置为该方法的默认行为。

## 优缺点

- 你可以避免创建者和具体产品之间的紧密耦合。
- 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
- 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。
- 应用工厂方法模式需要引入许多新的子类， 代码可能会因此 变得更复杂。 最好的情况是将该模式引入创建者类的现有层 次结构中。
