# 外观模式

**外观** 是一种结构型设计模式， 能为程序库、框架或其他复 杂类提供一个简单的接口。

## 结构

![类图-facade](https://raw.githubusercontent.com/hetchzhao/design-pattern/master/src/composite/class-design.png/类图-facade.png)

- **外观(Facade)**：提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求， 知晓如何操作一切活动部件。
- **创建附加外观(Additional Facade)**：可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。
- **复杂子系统(Complex Subsystem)**：由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节，比如按照正确顺序初始化对象和为其提供正 确格式的数据。
- **客户端(Client)**：使用外观代替对子系统对象的直接调用。

## 适合应用场景

- 如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式。

  子系统通常会随着时间的推进变得越来越复杂。 即便是应用 了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的，但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式，能够满足客户端的 大部分需求。

- 如果需要将子系统组织为多层结构，可以使用外观。

  创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互，以减少子系统之间的耦合。

## 实现方式

1. 考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。
2. 在一个新的外观类中声明并实现该接口。外观应将客户端代码的调用重定向到子系统中的相应对象处。如果客户端代码没有对子系统进行初始化，也没有对其后续生命周期进行管理，那么外观必须完成此类工作。
3. 如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响，比如子系统升级后，你只需修改外观中的代码即可。
4. 如果外观变得过于臃肿，你可以考虑将其部分行为抽取为一 个新的专用外观类。

## 分析

### 优点

- 你可以让自己的代码独立于复杂子系统。

### 缺点

- 外观可能成为与程序中所有类都耦合的上帝对象。
